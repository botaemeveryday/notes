---
title: Parametr pack
date: 2025-04-16
cover: images/cover.png
tags:
  - 2 семестр
  - Основы программирования
nolastmod: true
draft: false
---

**2 семестр** \
Основы программирования. 

<!--more-->

### Вариативные шаблоны
в 11 году - "рекурсивный" вызов функций с меньшим числом аргументов
На примере  функции `to_strings`:

```cpp
template<typename T, typename... Args>
to_strings(T value, Args... args){
// махинации с value
to_string(Args... args) //вызов функции от всез аргументов, кроме T value
}
```

По факту мы каждый раз преобразовываем только `value`, а потом запускаем эту же функцию от всех аргументов, кроме `value`. Тогда первый аргумент из `args` становится `value` и оно преобразуется. Дальше снова вызов от всех кроме `value` и тд. В таком случае нужна функция от 0 аргументов (это не круто)

- parametr pack - `...`
- модификаторы `const/volatile`
- `sizeof...`
- `fold-expression`

### Parametr pack
Применение:
- параметр шаблона - мб от 0 до n разных аргументов
- аргументы функции - также от 0 до n разных функций
- в `if constexpr`
- `sizeof..`.  - сколько штук лежит в параметр паке
- вызов функции от `args...` - вызов функции от всех аргументов параметр пака

Начиная с c++17:
- Fold-expression
	- Можно взять какой-то оператор и применить его к каждому аргументу parametr pack
	- Как бы написали то же, но вышло намного строчек меньше
	- функция каждый раз вызывается от одного аргумента...?
	- см сайд (разные виды расставления скобочек)
	- Применим для унарных и бинарных операторов
	- Разная установка скобочек важна для неассоциативных операций
		- справа - справа налево скобочки `(args / ...) (8/(4/2))`
		- слева - слева-направо скобочки `(../args)( (8/4)/2)`
		- расписать последние...

### comma fold Pattern
`func((args), ...)` - последовательность вызова функций для всех аргументов, т.е.  `func(arg0), func(arg1), func(arg2)...`
(посмотреть, что будет, если функция от 2-х аргументов)

Логично, что может быть и класс с переменным количеством аргументов
Главный пример - `std::pair`
- то же самое, что и пэир, но с переменным количеством
- Наивная реализация - через рекурсию
- Делаем класс на переменное число аргментов
- Делаем его специализацию на хеад и хвост, и на 0 аргументов
- Реализация аналогична с реализацией то стрин через рекурсию
- Наследуемся от тюпл (важно указание, что это специализация от хеад и тэил) с меньшим числом аргументов и в конструкторе конструируем одно полюшко и базовый класс
- чтобы получить боле внутренние величины по рекурсии, можно статиком кастить структруру к базовому классу
- сделаем поле с бейз и будем его конструировать, либо же просто храним ссылку на поле бейз (теперь можем получать величины как `t.base.base.value`)
- делаем шаблонный аргументт - индекс, чтобы получать итый тип
- делаем юзинг по ишке. Ещё нужна специализация для и `= 0`;

